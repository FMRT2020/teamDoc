# 方案一

2023/12/7  14:29

## 大前提

```
基于RISC-V32I的双发射变序执行流水线
	支持TAGE分支预测器
	主存采用海明纠错码技术
	支持基于Store Buffer的load转发
```

## 负责部分

```
I-Cache与Feach接口:
	Feach提供:
		要取的PC值
	I-cache提供:
		提供对应四个字(对于非四字对齐访问,提供排序Mask机制,将有效指令放前,无效指令放后面为0)
		?提供当前几位指令有效?方便取值阶段PC跳转逻辑?
		是否miss信号并充当cache ready信号,只要miss信号没有拉低上面PC就不能修改
		主存错误信号
		
I-cache与L2-cache接口:
	I-cache提供:
		I-cache miss使能信号
		miss的cache line编号(四字组号)
	L2-cache提供:
		四字对应数据信号
		L2-cache ready信号(L2-cache没有准备好的话不允许I-cache改变)
		#?程序自修改需要提供I-cache应置为无效的地址号->冲突(取时也无效,优先无效,在有效位和对应无效线或)
		主存错误信号
		
D-cache与Store Buffer接口:
	Store Buffer提供:
		写使能信号
		读使能信号
		对应PC地址
		32位数据
		字/半字/字节有效的模式-4bits
	D-cache提供:
		D-cache miss使能信号
		数据线
		主存错误信号
		
D-cache与L2-cache接口:
	D-cache提供:
		D-cache miss使能信号
		是否写回使能信号
		组号
		数据块
	L2-cache提供:
		数据块
		写回ready信号
		L2-cache ready信号
		主存错误信号
		
L2-cache与Main memory接口:(I miss优先处理,D miss的)
	L2-cache提供:
		miss使能信号
		是否写回使能信号
		地址组号
		数据块
	main memory提供:
		数据块
		写回ready信号
		main memory ready信号
		主存错误信号


对接取指阶段,初步想法是四取指->初步设想一个cache line存四个字
#支持程序自修改?若支持的话需要提供从L2-cache中获取一个
I-cache因为其主要是顺序取指令所以直接使用直接映射结构
D-cache因为数据访问随机性考虑使用2路组相连cache
L2-cache考虑使用4路组相连cache
主存使用海明纠错码机制

I-cache因为是直接映射结构所以每一个固定PC只对应一个位置,所以I-cache不需要考虑替换策略的问题,直接覆盖对应块
D-cache替换策略
L2-cache替换策略
```

### 地址划分

```
pc 32bits :
  组	      字		 字节
28bits	 2bits	  2bits
```



## 部分1:memory设计

```
目标:按着与L2-cache的接口设计初步实现支持海明纠错码的主存储器逻辑

思路:
	采用数据部分与纠错码部分分开存放的逻辑(主要是为了便于初始化)
	在使用testbanch测试时直接初始化数据和纠错码逻辑
	纠错机制:
		在从L2-cache写回主存时根据写回内容产生新的纠错码更新纠错码存储器
		在需要从主存读到L2-cache时根据读出的数据产生当前纠错码与存储纠错码对比产生控制信号
		00无错,01单错,1x无法恢复报错
	传输逻辑:
		1.没有miss信号时
			1.1.写回ready/主存ready/主存错误信号拉低
		2.若写回使能信号生效则进入写回逻辑->1 cycle
			2.1.依据当前数据组号向对应位置写入数据块
			2.2.产生对应纠错码
			2.3.写回ready拉高
		3.若写回使能信号未生效或已处理完写回->1 cycle
			3.1.本周期写回ready置0
			3.2.依据新的地址组号读主存
			3.3.检查对应纠错码输入到数据线
			3.4.mem ready信号拉高
			3.5.单纠错时同时更新主存对应位置
			3.6.无法恢复时主存错误信号拉高
			
	test方案:
		在主存初始化时直接将正确纠错码存储进纠错码存储器,主存数据部分可以选择存入错误数据,
		之后只需要观察读写状态即可
```

### 海明纠错码逻辑

```
一个主存单元32bits
因为本次毕业设计是四取指，两级cache组织中基本单位也是四字一组为基本单位
所以主存关于海明纠错码产生和更新逻辑也是以4*32=128bits为单位存储
以公式K=8 : 2^8-1 > 128 + 8 (因为海明纠错码保护的不只有数据位还要保护信息位)
则对于128bits的单错检查并恢复使用8bit纠错码逻辑
对于128bits的双错检查应额外使用1bit存储128+8对应的位异或结果:
	在之后的检查时:
		无错时:新异或结果==保留位
		单错时:新异或结果!=保留位,且单检错逻辑拉高
		双错时:新异或结果==保留位,且单检错逻辑拉高
		(更错错误时只能有限检查->比如发现不存在的位出错等)
		
考虑使用单个存储模块,因为海明纠错逻辑嵌入在了数据区,并需要其对应逻辑地址更改寄存器写入逻辑,所以考虑使用整块存储
```

### 主存bit划分

| 位置    | 逻辑内容     |      |
| ------- | ------------ | ---- |
| 0       | 双检错保留位 |      |
| 1       |              | c1   |
| 2       |              | c2   |
| 3       | d1           |      |
| 4       |              | c3   |
| 5-7     | d2-4         |      |
| 8       |              | c4   |
| 9-15    | d5-11        |      |
| 16      |              | c5   |
| 17-31   | d12-26       |      |
| 32      |              | c6   |
| 33-63   | d27-57       |      |
| 64      |              | c7   |
| 65-127  | d58-120      |      |
| 128     |              | c8   |
| 129-136 | d121-128     |      |

### 12/9 memory模块完成

2023/12/9 memory模块完成编写和仿真验证.

```
最终实现:
	写回需要4个周期
	不写回需要3个周期
	
	信号来1个周期
	写回数据1个周期
	读出数据进行纠错检查1个周期
	传回数据1个周期
```

## 部分2:L2cache设计

